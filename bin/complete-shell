#!/usr/bin/env bash

OPTIONS_SPEC="\
  $(basename $BASH_SOURCE) [<options>] <command> <arguments>

Commands:

  install <github-user/complete-'command'>
  add <complete-'command'.bash>
  rehash

See 'complete-shell help' for complete help.

Options:
--
h           Show the command summary
 
x           Debug - Turn on Bash trace (set -x) output
"

main() {
  check-env
  get-opts "$@"

  "__complete-shell:$command_name" "${command_args[@]}"
}

__complete-shell:add() {
  local file="$1"
  if [[ ! $file =~ ^/ ]]; then
    local dir="$(cd -P "$(dirname $file)"; pwd)"
    file="$dir/$(basename $file)"
  fi
  [[ $file =~ /complete-([^/]+).bash$ ]] ||
    die "Invalid file to add: '$file'"
  local name="${BASH_REMATCH[1]}"
  git config -f "$COMPLETE_SHELL_ROOT/config" \
    "complete-shell.$name" "$file"
  __complete-shell:rehash
}

__complete-shell:install() {
  local target="$1"
  [[ $target =~ ^([-_a-zA-Z0-9]+)/([-_a-zA-Z0-9]+)$ ]] ||
    die "Invalid install target '$target'"
  local dir="${BASH_REMATCH[2]}"
  [[ $dir =~ ^complete-([-_a-zA-Z0-9]+)$ ]] ||
    die "Invalid complete-shell repo name: '$dir'"
  local cmd_name="${BASH_REMATCH[1]}"
  local repo_path="$COMPLETE_SHELL_ROOT/source/$dir"
  git clone "https://github.com/$target" "$repo_path"
  __complete-shell:add "$repo_path/complete-$cmd_name.bash"
}

__complete-shell:rehash() {
  local all=(
    $(git config -f $COMPLETE_SHELL_ROOT/config --get-regexp complete-shell)
  )
  set -- "${all[@]}"
  while [[ $# -gt 0 ]]; do
    local cmd_name="${1#complete-shell.}" bash_file="$2"
    shift; shift
    source $bash_file || continue

    complete -F __complete-shell:add-completion "$cmd_name"
  done
}

__complete-shell:help() {
  exec man complete-shell
}

__complete-shell:add-completion() {
  local cmd="$1" word="$2" prev="$3"
  set -- $("__complete-shell::$cmd")
  COMPREPLY=()
  for arg; do
    if [[ -z $word || $arg =~ ^$word ]]; then
      COMPREPLY+=($arg)
    fi
  done
  return 0
}

check-env() {
  [[ -n "$COMPLETE_SHELL_ROOT" && -d "$COMPLETE_SHELL_ROOT" ]] ||
    die "complete-shell not properly activated"
}

get-opts() {
  if [ $# -eq 0 ]; then
    set -- --help
  else
    set -- "$@"
  fi

  rc=0
  parsed="$(
    echo "$OPTIONS_SPEC" |
    git rev-parse --parseopt -- "$@"
  )" || rc=$?
  if [ $rc -eq 0 ]; then
    eval "$parsed"
  else
    if [[ $PAGER == less ]]; then
      eval "$parsed" | less -FRX
    else
      eval "$parsed"
    fi
    exit $rc
  fi

  while [ $# -gt 0 ]; do
    local option="$1"; shift
    case "$option" in
      -c)
        cell_count="$1"
        shift
        ;;
      --) break ;;
      -x) set -x ;;
      *) error "unexpected option '$option'" ;;
    esac
  done

  command_name="$1"; shift
  command_args=("$@")

  can "__complete-shell:$command_name" ||
    die "Invalid command: '$command_name'"
}

die() { echo "$@" >&2; exit 1; }

can() {
  [ "$(type -t "$1")" == function ]
}

[[ $0 != $BASH_SOURCE ]] || main "$@"

# vim: set ft=sh sw=2 lisp:
